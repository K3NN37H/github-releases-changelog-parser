import{c as jt,a as F}from"../common/_commonjsHelpers-eb5a497e.js";var Tt=jt(function(h,v){(function(l,f){h.exports=f()})(F,function(){var l=typeof globalThis!="undefined"?globalThis:typeof window!="undefined"?window:typeof F!="undefined"?F:typeof self!="undefined"?self:{};function f(u){return u&&u.default||u}var y=function(u,e,t={}){var r,s,i;for(r in e)i=e[r],t[r]=(s=u[r])!=null?s:i;return t},I=function(u,e,t={}){var r,s;for(r in u)s=u[r],e[r]!==void 0&&(t[r]=s);return t},g={load:y,overwrite:I},D;D=class{constructor(e,t){this.incr=e,this.decr=t,this._first=null,this._last=null,this.length=0}push(e){var t;this.length++,typeof this.incr=="function"&&this.incr(),t={value:e,prev:this._last,next:null},this._last!=null?(this._last.next=t,this._last=t):this._first=this._last=t}shift(){var e;if(this._first!=null)return this.length--,typeof this.decr=="function"&&this.decr(),e=this._first.value,(this._first=this._first.next)!=null?this._first.prev=null:this._last=null,e}first(){if(this._first!=null)return this._first.value}getArray(){var e,t,r;for(e=this._first,r=[];e!=null;)r.push((t=e,e=e.next,t.value));return r}forEachShift(e){var t;for(t=this.shift();t!=null;)e(t),t=this.shift()}debug(){var e,t,r,s,i;for(e=this._first,i=[];e!=null;)i.push((t=e,e=e.next,{value:t.value,prev:(r=t.prev)!=null?r.value:void 0,next:(s=t.next)!=null?s.value:void 0}));return i}};var c=D,w;w=class{constructor(e){if(this.instance=e,this._events={},this.instance.on!=null||this.instance.once!=null||this.instance.removeAllListeners!=null)throw new Error("An Emitter already exists for this object");this.instance.on=(t,r)=>this._addListener(t,"many",r),this.instance.once=(t,r)=>this._addListener(t,"once",r),this.instance.removeAllListeners=(t=null)=>t!=null?delete this._events[t]:this._events={}}_addListener(e,t,r){var s;return(s=this._events)[e]==null&&(s[e]=[]),this._events[e].push({cb:r,status:t}),this.instance}listenerCount(e){return this._events[e]!=null?this._events[e].length:0}async trigger(e,...t){var r,s;try{return e!=="debug"&&this.trigger("debug",`Event triggered: ${e}`,t),this._events[e]==null?void 0:(this._events[e]=this._events[e].filter(function(i){return i.status!=="none"}),s=this._events[e].map(async i=>{var n,o;if(i.status!=="none"){i.status==="once"&&(i.status="none");try{return o=typeof i.cb=="function"?i.cb(...t):void 0,typeof(o!=null?o.then:void 0)=="function"?await o:o}catch(a){return n=a,this.trigger("error",n),null}}}),(await Promise.all(s)).find(function(i){return i!=null}))}catch(i){return r=i,this.trigger("error",r),null}}};var m=w,p,$,E;p=c,$=m,E=class{constructor(e){this.Events=new $(this),this._length=0,this._lists=function(){var t,r,s;for(s=[],t=1,r=e;1<=r?t<=r:t>=r;1<=r?++t:--t)s.push(new p(()=>this.incr(),()=>this.decr()));return s}.call(this)}incr(){if(this._length++==0)return this.Events.trigger("leftzero")}decr(){if(--this._length==0)return this.Events.trigger("zero")}push(e){return this._lists[e.options.priority].push(e)}queued(e){return e!=null?this._lists[e].length:this._length}shiftAll(e){return this._lists.forEach(function(t){return t.forEachShift(e)})}getFirst(e=this._lists){var t,r,s;for(t=0,r=e.length;t<r;t++)if(s=e[t],s.length>0)return s;return[]}shiftLastFrom(e){return this.getFirst(this._lists.slice(e).reverse()).shift()}};var A=E,S;S=class extends Error{};var x=S,k,j,R,O,q;O=10,j=5,q=g,k=x,R=class{constructor(e,t,r,s,i,n,o,a){this.task=e,this.args=t,this.rejectOnDrop=i,this.Events=n,this._states=o,this.Promise=a,this.options=q.load(r,s),this.options.priority=this._sanitizePriority(this.options.priority),this.options.id===s.id&&(this.options.id=`${this.options.id}-${this._randomIndex()}`),this.promise=new this.Promise((d,_)=>{this._resolve=d,this._reject=_}),this.retryCount=0}_sanitizePriority(e){var t;return t=~~e!==e?j:e,t<0?0:t>O-1?O-1:t}_randomIndex(){return Math.random().toString(36).slice(2)}doDrop({error:e,message:t="This job has been dropped by Bottleneck"}={}){return this._states.remove(this.options.id)?(this.rejectOnDrop&&this._reject(e!=null?e:new k(t)),this.Events.trigger("dropped",{args:this.args,options:this.options,task:this.task,promise:this.promise}),!0):!1}_assertStatus(e){var t;if(t=this._states.jobStatus(this.options.id),!(t===e||e==="DONE"&&t===null))throw new k(`Invalid job status ${t}, expected ${e}. Please open an issue at https://github.com/SGrondin/bottleneck/issues`)}doReceive(){return this._states.start(this.options.id),this.Events.trigger("received",{args:this.args,options:this.options})}doQueue(e,t){return this._assertStatus("RECEIVED"),this._states.next(this.options.id),this.Events.trigger("queued",{args:this.args,options:this.options,reachedHWM:e,blocked:t})}doRun(){return this.retryCount===0?(this._assertStatus("QUEUED"),this._states.next(this.options.id)):this._assertStatus("EXECUTING"),this.Events.trigger("scheduled",{args:this.args,options:this.options})}async doExecute(e,t,r,s){var i,n,o;this.retryCount===0?(this._assertStatus("RUNNING"),this._states.next(this.options.id)):this._assertStatus("EXECUTING"),n={args:this.args,options:this.options,retryCount:this.retryCount},this.Events.trigger("executing",n);try{if(o=await(e!=null?e.schedule(this.options,this.task,...this.args):this.task(...this.args)),t())return this.doDone(n),await s(this.options,n),this._assertStatus("DONE"),this._resolve(o)}catch(a){return i=a,this._onFailure(i,n,t,r,s)}}doExpire(e,t,r){var s,i;return this._states.jobStatus(this.options.id==="RUNNING")&&this._states.next(this.options.id),this._assertStatus("EXECUTING"),i={args:this.args,options:this.options,retryCount:this.retryCount},s=new k(`This job timed out after ${this.options.expiration} ms.`),this._onFailure(s,i,e,t,r)}async _onFailure(e,t,r,s,i){var n,o;if(r())return n=await this.Events.trigger("failed",e,t),n!=null?(o=~~n,this.Events.trigger("retry",`Retrying ${this.options.id} after ${o} ms`,t),this.retryCount++,s(o)):(this.doDone(t),await i(this.options,t),this._assertStatus("DONE"),this._reject(e))}doDone(e){return this._assertStatus("EXECUTING"),this._states.next(this.options.id),this.Events.trigger("done",e)}};var yt=R,W,V,P;P=g,W=x,V=class{constructor(e,t,r){this.instance=e,this.storeOptions=t,this.clientId=this.instance._randomIndex(),P.load(r,r,this),this._nextRequest=this._lastReservoirRefresh=this._lastReservoirIncrease=Date.now(),this._running=0,this._done=0,this._unblockTime=0,this.ready=this.Promise.resolve(),this.clients={},this._startHeartbeat()}_startHeartbeat(){var e;return this.heartbeat==null&&(this.storeOptions.reservoirRefreshInterval!=null&&this.storeOptions.reservoirRefreshAmount!=null||this.storeOptions.reservoirIncreaseInterval!=null&&this.storeOptions.reservoirIncreaseAmount!=null)?typeof(e=this.heartbeat=setInterval(()=>{var t,r,s,i,n;if(i=Date.now(),this.storeOptions.reservoirRefreshInterval!=null&&i>=this._lastReservoirRefresh+this.storeOptions.reservoirRefreshInterval&&(this._lastReservoirRefresh=i,this.storeOptions.reservoir=this.storeOptions.reservoirRefreshAmount,this.instance._drainAll(this.computeCapacity())),this.storeOptions.reservoirIncreaseInterval!=null&&i>=this._lastReservoirIncrease+this.storeOptions.reservoirIncreaseInterval&&({reservoirIncreaseAmount:t,reservoirIncreaseMaximum:s,reservoir:n}=this.storeOptions,this._lastReservoirIncrease=i,r=s!=null?Math.min(t,s-n):t,r>0))return this.storeOptions.reservoir+=r,this.instance._drainAll(this.computeCapacity())},this.heartbeatInterval)).unref=="function"?e.unref():void 0:clearInterval(this.heartbeat)}async __publish__(e){return await this.yieldLoop(),this.instance.Events.trigger("message",e.toString())}async __disconnect__(e){return await this.yieldLoop(),clearInterval(this.heartbeat),this.Promise.resolve()}yieldLoop(e=0){return new this.Promise(function(t,r){return setTimeout(t,e)})}computePenalty(){var e;return(e=this.storeOptions.penalty)!=null?e:15*this.storeOptions.minTime||5e3}async __updateSettings__(e){return await this.yieldLoop(),P.overwrite(e,e,this.storeOptions),this._startHeartbeat(),this.instance._drainAll(this.computeCapacity()),!0}async __running__(){return await this.yieldLoop(),this._running}async __queued__(){return await this.yieldLoop(),this.instance.queued()}async __done__(){return await this.yieldLoop(),this._done}async __groupCheck__(e){return await this.yieldLoop(),this._nextRequest+this.timeout<e}computeCapacity(){var e,t;return{maxConcurrent:e,reservoir:t}=this.storeOptions,e!=null&&t!=null?Math.min(e-this._running,t):e!=null?e-this._running:t!=null?t:null}conditionsCheck(e){var t;return t=this.computeCapacity(),t==null||e<=t}async __incrementReservoir__(e){var t;return await this.yieldLoop(),t=this.storeOptions.reservoir+=e,this.instance._drainAll(this.computeCapacity()),t}async __currentReservoir__(){return await this.yieldLoop(),this.storeOptions.reservoir}isBlocked(e){return this._unblockTime>=e}check(e,t){return this.conditionsCheck(e)&&this._nextRequest-t<=0}async __check__(e){var t;return await this.yieldLoop(),t=Date.now(),this.check(e,t)}async __register__(e,t,r){var s,i;return await this.yieldLoop(),s=Date.now(),this.conditionsCheck(t)?(this._running+=t,this.storeOptions.reservoir!=null&&(this.storeOptions.reservoir-=t),i=Math.max(this._nextRequest-s,0),this._nextRequest=s+i+this.storeOptions.minTime,{success:!0,wait:i,reservoir:this.storeOptions.reservoir}):{success:!1}}strategyIsBlock(){return this.storeOptions.strategy===3}async __submit__(e,t){var r,s,i;if(await this.yieldLoop(),this.storeOptions.maxConcurrent!=null&&t>this.storeOptions.maxConcurrent)throw new W(`Impossible to add a job having a weight of ${t} to a limiter having a maxConcurrent setting of ${this.storeOptions.maxConcurrent}`);return s=Date.now(),i=this.storeOptions.highWater!=null&&e===this.storeOptions.highWater&&!this.check(t,s),r=this.strategyIsBlock()&&(i||this.isBlocked(s)),r&&(this._unblockTime=s+this.computePenalty(),this._nextRequest=this._unblockTime+this.storeOptions.minTime,this.instance._dropAllQueued()),{reachedHWM:i,blocked:r,strategy:this.storeOptions.strategy}}async __free__(e,t){return await this.yieldLoop(),this._running-=t,this._done+=t,this.instance._drainAll(this.computeCapacity()),{running:this._running}}};var wt=V,K,z;K=x,z=class{constructor(e){this.status=e,this._jobs={},this.counts=this.status.map(function(){return 0})}next(e){var t,r;if(t=this._jobs[e],r=t+1,t!=null&&r<this.status.length)return this.counts[t]--,this.counts[r]++,this._jobs[e]++;if(t!=null)return this.counts[t]--,delete this._jobs[e]}start(e){var t;return t=0,this._jobs[e]=t,this.counts[t]++}remove(e){var t;return t=this._jobs[e],t!=null&&(this.counts[t]--,delete this._jobs[e]),t!=null}jobStatus(e){var t;return(t=this.status[this._jobs[e]])!=null?t:null}statusJobs(e){var t,r,s,i,n;if(e!=null){if(r=this.status.indexOf(e),r<0)throw new K(`status must be one of ${this.status.join(", ")}`);s=this._jobs,i=[];for(t in s)n=s[t],n===r&&i.push(t);return i}else return Object.keys(this._jobs)}statusCounts(){return this.counts.reduce((e,t,r)=>(e[this.status[r]]=t,e),{})}};var bt=z,Y,J;Y=c,J=class{constructor(e,t){this.schedule=this.schedule.bind(this),this.name=e,this.Promise=t,this._running=0,this._queue=new Y}isEmpty(){return this._queue.length===0}async _tryToRun(){var e,t,r,s,i,n,o;if(this._running<1&&this._queue.length>0)return this._running++,{task:o,args:e,resolve:i,reject:s}=this._queue.shift(),t=await async function(){try{return n=await o(...e),function(){return i(n)}}catch(a){return r=a,function(){return s(r)}}}(),this._running--,this._tryToRun(),t()}schedule(e,...t){var r,s,i;return i=s=null,r=new this.Promise(function(n,o){return i=n,s=o}),this._queue.push({task:e,args:t,resolve:i,reject:s}),this._tryToRun(),r}};var Et=J,H="2.19.5",Rt={version:H},Ot=Object.freeze({version:H,default:Rt}),X=()=>console.log("You must import the full version of Bottleneck in order to use this feature."),Z=()=>console.log("You must import the full version of Bottleneck in order to use this feature."),xt=()=>console.log("You must import the full version of Bottleneck in order to use this feature."),tt,et,rt,st,it,T;T=g,tt=m,st=X,rt=Z,it=xt,et=function(){class u{constructor(t={}){this.deleteKey=this.deleteKey.bind(this),this.limiterOptions=t,T.load(this.limiterOptions,this.defaults,this),this.Events=new tt(this),this.instances={},this.Bottleneck=ft,this._startAutoCleanup(),this.sharedConnection=this.connection!=null,this.connection==null&&(this.limiterOptions.datastore==="redis"?this.connection=new st(Object.assign({},this.limiterOptions,{Events:this.Events})):this.limiterOptions.datastore==="ioredis"&&(this.connection=new rt(Object.assign({},this.limiterOptions,{Events:this.Events}))))}key(t=""){var r;return(r=this.instances[t])!=null?r:(()=>{var s;return s=this.instances[t]=new this.Bottleneck(Object.assign(this.limiterOptions,{id:`${this.id}-${t}`,timeout:this.timeout,connection:this.connection})),this.Events.trigger("created",s,t),s})()}async deleteKey(t=""){var r,s;return s=this.instances[t],this.connection&&(r=await this.connection.__runCommand__(["del",...it.allKeys(`${this.id}-${t}`)])),s!=null&&(delete this.instances[t],await s.disconnect()),s!=null||r>0}limiters(){var t,r,s,i;r=this.instances,s=[];for(t in r)i=r[t],s.push({key:t,limiter:i});return s}keys(){return Object.keys(this.instances)}async clusterKeys(){var t,r,s,i,n,o,a,d,_;if(this.connection==null)return this.Promise.resolve(this.keys());for(o=[],t=null,_=`b_${this.id}-`.length,r="_settings".length;t!==0;)for([d,s]=await this.connection.__runCommand__(["scan",t!=null?t:0,"match",`b_${this.id}-*_settings`,"count",1e4]),t=~~d,i=0,a=s.length;i<a;i++)n=s[i],o.push(n.slice(_,-r));return o}_startAutoCleanup(){var t;return clearInterval(this.interval),typeof(t=this.interval=setInterval(async()=>{var r,s,i,n,o,a;o=Date.now(),i=this.instances,n=[];for(s in i){a=i[s];try{await a._store.__groupCheck__(o)?n.push(this.deleteKey(s)):n.push(void 0)}catch(d){r=d,n.push(a.Events.trigger("error",r))}}return n},this.timeout/2)).unref=="function"?t.unref():void 0}updateSettings(t={}){if(T.overwrite(t,this.defaults,this),T.overwrite(t,t,this.limiterOptions),t.timeout!=null)return this._startAutoCleanup()}disconnect(t=!0){var r;if(!this.sharedConnection)return(r=this.connection)!=null?r.disconnect(t):void 0}}return u.prototype.defaults={timeout:1e3*60*5,connection:null,Promise,id:"group-key"},u}.call(l);var kt=et,nt,ot,ut;ut=g,ot=m,nt=function(){class u{constructor(t={}){this.options=t,ut.load(this.options,this.defaults,this),this.Events=new ot(this),this._arr=[],this._resetPromise(),this._lastFlush=Date.now()}_resetPromise(){return this._promise=new this.Promise((t,r)=>this._resolve=t)}_flush(){return clearTimeout(this._timeout),this._lastFlush=Date.now(),this._resolve(),this.Events.trigger("batch",this._arr),this._arr=[],this._resetPromise()}add(t){var r;return this._arr.push(t),r=this._promise,this._arr.length===this.maxSize?this._flush():this.maxTime!=null&&this._arr.length===1&&(this._timeout=setTimeout(()=>this._flush(),this.maxTime)),r}}return u.prototype.defaults={maxTime:null,maxSize:null,Promise},u}.call(l);var Lt=nt,It=()=>console.log("You must import the full version of Bottleneck in order to use this feature."),Dt=f(Ot),at,ht,G,N,lt,B,ct,dt,_t,M,b,pt=[].splice;B=10,ht=5,b=g,ct=A,N=yt,lt=wt,dt=It,G=m,_t=bt,M=Et,at=function(){class u{constructor(t={},...r){var s,i;this._addToQueue=this._addToQueue.bind(this),this._validateOptions(t,r),b.load(t,this.instanceDefaults,this),this._queues=new ct(B),this._scheduled={},this._states=new _t(["RECEIVED","QUEUED","RUNNING","EXECUTING"].concat(this.trackDoneStatus?["DONE"]:[])),this._limiter=null,this.Events=new G(this),this._submitLock=new M("submit",this.Promise),this._registerLock=new M("register",this.Promise),i=b.load(t,this.storeDefaults,{}),this._store=function(){if(this.datastore==="redis"||this.datastore==="ioredis"||this.connection!=null)return s=b.load(t,this.redisStoreDefaults,{}),new dt(this,i,s);if(this.datastore==="local")return s=b.load(t,this.localStoreDefaults,{}),new lt(this,i,s);throw new u.prototype.BottleneckError(`Invalid datastore type: ${this.datastore}`)}.call(this),this._queues.on("leftzero",()=>{var n;return(n=this._store.heartbeat)!=null&&typeof n.ref=="function"?n.ref():void 0}),this._queues.on("zero",()=>{var n;return(n=this._store.heartbeat)!=null&&typeof n.unref=="function"?n.unref():void 0})}_validateOptions(t,r){if(!(t!=null&&typeof t=="object"&&r.length===0))throw new u.prototype.BottleneckError("Bottleneck v2 takes a single object argument. Refer to https://github.com/SGrondin/bottleneck#upgrading-to-v2 if you're upgrading from Bottleneck v1.")}ready(){return this._store.ready}clients(){return this._store.clients}channel(){return`b_${this.id}`}channel_client(){return`b_${this.id}_${this._store.clientId}`}publish(t){return this._store.__publish__(t)}disconnect(t=!0){return this._store.__disconnect__(t)}chain(t){return this._limiter=t,this}queued(t){return this._queues.queued(t)}clusterQueued(){return this._store.__queued__()}empty(){return this.queued()===0&&this._submitLock.isEmpty()}running(){return this._store.__running__()}done(){return this._store.__done__()}jobStatus(t){return this._states.jobStatus(t)}jobs(t){return this._states.statusJobs(t)}counts(){return this._states.statusCounts()}_randomIndex(){return Math.random().toString(36).slice(2)}check(t=1){return this._store.__check__(t)}_clearGlobalState(t){return this._scheduled[t]!=null?(clearTimeout(this._scheduled[t].expiration),delete this._scheduled[t],!0):!1}async _free(t,r,s,i){var n,o;try{if({running:o}=await this._store.__free__(t,s.weight),this.Events.trigger("debug",`Freed ${s.id}`,i),o===0&&this.empty())return this.Events.trigger("idle")}catch(a){return n=a,this.Events.trigger("error",n)}}_run(t,r,s){var i,n,o;return r.doRun(),i=this._clearGlobalState.bind(this,t),o=this._run.bind(this,t,r),n=this._free.bind(this,t,r),this._scheduled[t]={timeout:setTimeout(()=>r.doExecute(this._limiter,i,o,n),s),expiration:r.options.expiration!=null?setTimeout(function(){return r.doExpire(i,o,n)},s+r.options.expiration):void 0,job:r}}_drainOne(t){return this._registerLock.schedule(()=>{var r,s,i,n,o;return this.queued()===0?this.Promise.resolve(null):(o=this._queues.getFirst(),{options:n,args:r}=i=o.first(),t!=null&&n.weight>t?this.Promise.resolve(null):(this.Events.trigger("debug",`Draining ${n.id}`,{args:r,options:n}),s=this._randomIndex(),this._store.__register__(s,n.weight,n.expiration).then(({success:a,wait:d,reservoir:_})=>{var C;return this.Events.trigger("debug",`Drained ${n.id}`,{success:a,args:r,options:n}),a?(o.shift(),C=this.empty(),C&&this.Events.trigger("empty"),_===0&&this.Events.trigger("depleted",C),this._run(s,i,d),this.Promise.resolve(n.weight)):this.Promise.resolve(null)})))})}_drainAll(t,r=0){return this._drainOne(t).then(s=>{var i;return s!=null?(i=t!=null?t-s:t,this._drainAll(i,r+s)):this.Promise.resolve(r)}).catch(s=>this.Events.trigger("error",s))}_dropAllQueued(t){return this._queues.shiftAll(function(r){return r.doDrop({message:t})})}stop(t={}){var r,s;return t=b.load(t,this.stopDefaults),s=i=>{var n;return n=()=>{var o;return o=this._states.counts,o[0]+o[1]+o[2]+o[3]===i},new this.Promise((o,a)=>n()?o():this.on("done",()=>{if(n())return this.removeAllListeners("done"),o()}))},r=t.dropWaitingJobs?(this._run=function(i,n){return n.doDrop({message:t.dropErrorMessage})},this._drainOne=()=>this.Promise.resolve(null),this._registerLock.schedule(()=>this._submitLock.schedule(()=>{var i,n,o;n=this._scheduled;for(i in n)o=n[i],this.jobStatus(o.job.options.id)==="RUNNING"&&(clearTimeout(o.timeout),clearTimeout(o.expiration),o.job.doDrop({message:t.dropErrorMessage}));return this._dropAllQueued(t.dropErrorMessage),s(0)}))):this.schedule({priority:B-1,weight:0},()=>s(1)),this._receive=function(i){return i._reject(new u.prototype.BottleneckError(t.enqueueErrorMessage))},this.stop=()=>this.Promise.reject(new u.prototype.BottleneckError("stop() has already been called")),r}async _addToQueue(t){var r,s,i,n,o,a,d;({args:r,options:n}=t);try{({reachedHWM:o,blocked:s,strategy:d}=await this._store.__submit__(this.queued(),n.weight))}catch(_){return i=_,this.Events.trigger("debug",`Could not queue ${n.id}`,{args:r,options:n,error:i}),t.doDrop({error:i}),!1}return s?(t.doDrop(),!0):o&&(a=d===u.prototype.strategy.LEAK?this._queues.shiftLastFrom(n.priority):d===u.prototype.strategy.OVERFLOW_PRIORITY?this._queues.shiftLastFrom(n.priority+1):d===u.prototype.strategy.OVERFLOW?t:void 0,a!=null&&a.doDrop(),a==null||d===u.prototype.strategy.OVERFLOW)?(a==null&&t.doDrop(),o):(t.doQueue(o,s),this._queues.push(t),await this._drainAll(),o)}_receive(t){return this._states.jobStatus(t.options.id)!=null?(t._reject(new u.prototype.BottleneckError(`A job with the same id already exists (id=${t.options.id})`)),!1):(t.doReceive(),this._submitLock.schedule(this._addToQueue,t))}submit(...t){var r,s,i,n,o,a,d;return typeof t[0]=="function"?(o=t,[s,...t]=o,[r]=pt.call(t,-1),n=b.load({},this.jobDefaults)):(a=t,[n,s,...t]=a,[r]=pt.call(t,-1),n=b.load(n,this.jobDefaults)),d=(..._)=>new this.Promise(function(C,Ct){return s(..._,function(...vt){return(vt[0]!=null?Ct:C)(vt)})}),i=new N(d,t,n,this.jobDefaults,this.rejectOnDrop,this.Events,this._states,this.Promise),i.promise.then(function(_){return typeof r=="function"?r(..._):void 0}).catch(function(_){return Array.isArray(_)?typeof r=="function"?r(..._):void 0:typeof r=="function"?r(_):void 0}),this._receive(i)}schedule(...t){var r,s,i;return typeof t[0]=="function"?([i,...t]=t,s={}):[s,i,...t]=t,r=new N(i,t,s,this.jobDefaults,this.rejectOnDrop,this.Events,this._states,this.Promise),this._receive(r),r.promise}wrap(t){var r,s;return r=this.schedule.bind(this),s=function(...i){return r(t.bind(this),...i)},s.withOptions=function(i,...n){return r(i,t,...n)},s}async updateSettings(t={}){return await this._store.__updateSettings__(b.overwrite(t,this.storeDefaults)),b.overwrite(t,this.instanceDefaults,this),this}currentReservoir(){return this._store.__currentReservoir__()}incrementReservoir(t=0){return this._store.__incrementReservoir__(t)}}return u.default=u,u.Events=G,u.version=u.prototype.version=Dt.version,u.strategy=u.prototype.strategy={LEAK:1,OVERFLOW:2,OVERFLOW_PRIORITY:4,BLOCK:3},u.BottleneckError=u.prototype.BottleneckError=x,u.Group=u.prototype.Group=kt,u.RedisConnection=u.prototype.RedisConnection=X,u.IORedisConnection=u.prototype.IORedisConnection=Z,u.Batcher=u.prototype.Batcher=Lt,u.prototype.jobDefaults={priority:ht,weight:1,expiration:null,id:"<no-id>"},u.prototype.storeDefaults={maxConcurrent:null,minTime:0,highWater:null,strategy:u.prototype.strategy.LEAK,penalty:null,reservoir:null,reservoirRefreshInterval:null,reservoirRefreshAmount:null,reservoirIncreaseInterval:null,reservoirIncreaseAmount:null,reservoirIncreaseMaximum:null},u.prototype.localStoreDefaults={Promise,timeout:null,heartbeatInterval:250},u.prototype.redisStoreDefaults={Promise,timeout:null,heartbeatInterval:5e3,clientTimeout:1e4,Redis:null,clientOptions:{},clusterNodes:null,clearDatastore:!1,connection:null},u.prototype.instanceDefaults={datastore:"local",connection:null,id:"<no-id>",rejectOnDrop:!0,trackDoneStatus:!1,Promise},u.prototype.stopDefaults={enqueueErrorMessage:"This limiter has been stopped and cannot accept new jobs.",dropWaitingJobs:!0,dropErrorMessage:"This limiter has been stopped."},u}.call(l);var ft=at,$t=ft;return $t})});const At="3.5.2",Q=()=>Promise.resolve();function St(h,v,l){return h.retryLimiter.schedule(qt,h,v,l)}async function qt(h,v,l){const f=l.method!=="GET"&&l.method!=="HEAD",{pathname:y}=new URL(l.url,"http://github.test"),I=l.method==="GET"&&y.startsWith("/search/"),g=y.startsWith("/graphql"),c=~~l.request.retryCount>0?{priority:0,weight:0}:{};h.clustering&&(c.expiration=1e3*60),(f||g)&&await h.write.key(h.id).schedule(c,Q),f&&h.triggersNotification(y)&&await h.notifications.key(h.id).schedule(c,Q),I&&await h.search.key(h.id).schedule(c,Q);const w=h.global.key(h.id).schedule(c,v,l);if(g){const m=await w;if(m.data.errors!=null&&m.data.errors.some(p=>p.type==="RATE_LIMITED"))throw Object.assign(new Error("GraphQL Rate Limit Exceeded"),{response:m,data:m.data})}return w}var Pt=["/orgs/{org}/invitations","/orgs/{org}/invitations/{invitation_id}","/orgs/{org}/teams/{team_slug}/discussions","/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments","/repos/{owner}/{repo}/collaborators/{username}","/repos/{owner}/{repo}/commits/{commit_sha}/comments","/repos/{owner}/{repo}/issues","/repos/{owner}/{repo}/issues/{issue_number}/comments","/repos/{owner}/{repo}/pulls","/repos/{owner}/{repo}/pulls/{pull_number}/comments","/repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies","/repos/{owner}/{repo}/pulls/{pull_number}/merge","/repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers","/repos/{owner}/{repo}/pulls/{pull_number}/reviews","/repos/{owner}/{repo}/releases","/teams/{team_id}/discussions","/teams/{team_id}/discussions/{discussion_number}/comments"];function Gt(h){const l=`^(?:${h.map(f=>f.split("/").map(y=>y.startsWith("{")?"(?:.+?)":y).join("/")).map(f=>`(?:${f})`).join("|")})[^/]*$`;return new RegExp(l,"i")}const mt=Gt(Pt),gt=mt.test.bind(mt),L={},Nt=function(h,v){L.global=new h.Group({id:"octokit-global",maxConcurrent:10,...v}),L.search=new h.Group({id:"octokit-search",maxConcurrent:1,minTime:2e3,...v}),L.write=new h.Group({id:"octokit-write",maxConcurrent:1,minTime:1e3,...v}),L.notifications=new h.Group({id:"octokit-notifications",maxConcurrent:1,minTime:3e3,...v})};function U(h,v={}){const{enabled:l=!0,Bottleneck:f=Tt,id:y="no-id",timeout:I=1e3*60*2,connection:g}=v.throttle||{};if(!l)return{};const D={connection:g,timeout:I};L.global==null&&Nt(f,D);const c=Object.assign({clustering:g!=null,triggersNotification:gt,minimumAbuseRetryAfter:5,retryAfterBaseValue:1e3,retryLimiter:new f,id:y,...L},v.throttle);if(typeof c.onAbuseLimit!="function"||typeof c.onRateLimit!="function")throw new Error(`octokit/plugin-throttling error:
        You must pass the onAbuseLimit and onRateLimit error handlers.
        See https://github.com/octokit/rest.js#throttling

        const octokit = new Octokit({
          throttle: {
            onAbuseLimit: (retryAfter, options) => {/* ... */},
            onRateLimit: (retryAfter, options) => {/* ... */}
          }
        })
    `);const w={},m=new f.Events(w);return w.on("abuse-limit",c.onAbuseLimit),w.on("rate-limit",c.onRateLimit),w.on("error",p=>console.warn("Error in throttling-plugin limit handler",p)),c.retryLimiter.on("failed",async function(p,$){const E=$.args[$.args.length-1],{pathname:A}=new URL(E.url,"http://github.test");if(!(A.startsWith("/graphql")&&p.status!==401||p.status===403))return;const x=~~E.request.retryCount;E.request.retryCount=x;const{wantRetry:k,retryAfter:j}=await async function(){if(/\bsecondary rate\b/i.test(p.message)){const R=Math.max(~~p.response.headers["retry-after"],c.minimumAbuseRetryAfter);return{wantRetry:await m.trigger("abuse-limit",R,E,h),retryAfter:R}}if(p.response.headers!=null&&p.response.headers["x-ratelimit-remaining"]==="0"){const R=new Date(~~p.response.headers["x-ratelimit-reset"]*1e3).getTime(),O=Math.max(Math.ceil((R-Date.now())/1e3),0);return{wantRetry:await m.trigger("rate-limit",O,E,h),retryAfter:O}}return{}}();if(k)return E.request.retryCount++,j*c.retryAfterBaseValue}),h.hook.wrap("request",St.bind(null,c)),{}}U.VERSION=At,U.triggersNotification=gt;export{U as throttling};
